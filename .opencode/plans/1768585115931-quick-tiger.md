# Plan: templ templates + real sqlite/sqlc DB store

## Goal
Extend `entry-watch` with:

1) Template work using `templ` (with a note to check the `reference-proyect` for syntax/patterns when unsure).
2) A real database-backed store implementation using `sqlc + sqlite`.
   - Production uses sqlite file at `./data/db.sqlite3` by default.
   - Tests migrate to use an in-memory sqlite DB per test.
   - Per your decision: **replace `MemStore`** (prod and tests should use the sql-backed store).

Non-goals:
- No new config system yet (DSN will be hardcoded default + env override).
- No UI redesign beyond what’s required by routes/templates.

---

## Current state (from repo scan)

### templ
- `.templ` sources exist under `internal/templates/**`.
- Generated `*_templ.go` are checked in.
- Templ generation is Makefile-driven:
  - `make templates` runs `go tool templ generate -lazy`
  - `make build` depends on `templates` (and `sqlc`).

### sqlc/sqlite
- `sqlc.yaml` already exists and is configured for sqlite:
  - schema: `db/migrations`
  - queries: `db/sqlc` (currently missing)
  - generated Go: `internal/sqlc` (currently missing)
- Migrations exist and are embedded for goose:
  - `db/migrate.go` runs goose with dialect `sqlite3`
- `cmd/entry-watch/main.go` currently uses `entry.NewMemStore()` and imports `_ "modernc.org/sqlite"`.

### tests
- Only test currently: `internal/entry/app_test.go`, uses `NewMemStore()`.

---

## Templates (templ)

### Work items
1) Audit existing templates and add any missing ones for current HTTP routes UI.
   - In particular: ensure `/auth/login` template exists and matches handler expectations.
2) Ensure templates follow existing composition patterns:
   - shared layout in `internal/templates/common/layout.templ`
   - navbars in `internal/templates/common/navbar.templ` and feature navbars under feature folders.
3) Add/adjust handler rendering to use templ components consistently.

### Note: reference project
If there’s any doubt about templ syntax or component composition, check the `reference-proyect` templates/components for:
- how layouts are composed
- how props are passed
- escaping/attribute syntax
- conditional rendering loops

(We’ll keep repo-local templates minimal and consistent with current `internal/templates/**` patterns.)

### Likely files
- `internal/templates/common/layout.templ`
- `internal/templates/common/navbar.templ`
- `internal/templates/user/*.templ`
- `internal/http/auth/*.go` (login page rendering)
- `internal/http/**` handlers that render HTML.

---

## Real DB store (sqlite + sqlc)

### High-level approach
- Introduce a sqlite/sqlc-backed store that implements `internal/entry.Store`.
- Replace `MemStore` usage in `cmd/entry-watch/main.go` with sqlite store.
- Update tests to use an in-memory sqlite DB per test.
- Keep `sqlc.yaml` paths as-is: create `db/sqlc/*.sql` and generate into `internal/sqlc`.

### Step 1 — Inventory store interfaces and required queries
Read/confirm exact method sets for:
- `internal/entry/user_store.go`
- `internal/entry/condominium_store.go` (or wherever it lives)
- `internal/entry/visit_store.go` (or wherever it lives)
- any audit log store interface if present

Then map each method to a sqlc query (or a small set of queries). Ensure the SQL aligns with `db/migrations/20251123181233_init.sql`.

### Step 2 — Create sqlc query files
Create the missing directory:
- `db/sqlc/`

Add query files, split by domain for readability:
- `db/sqlc/users.sql`
- `db/sqlc/condominiums.sql`
- `db/sqlc/visits.sql`
- (optional) `db/sqlc/audit_logs.sql`

Each query should have sqlc names matching the store methods, e.g.:
- `-- name: UserGetByID :one`
- `-- name: UserGetByEmail :one`
- `-- name: UserCreate :one`
- `-- name: UserCountByRole :one`

Design notes:
- Preserve existing schema column name `users.password` (treat as password hash).
- Convert `sql.ErrNoRows` to `entry.ErrNotFound` (to keep handler behavior stable).

### Step 3 — Run sqlc and wire generated code
Generate into `internal/sqlc` (per `sqlc.yaml`).
- Ensure Makefile `sqlc` target works (it already exists in `makefile`).
- Verify `go test` compiles with generated package.

### Step 4 — Implement sqlite-backed store
Create a new store implementation (package name TBD, but suggested):
- `internal/entry/sqlstore/`

Structure:
- `type Store struct { db *sql.DB; q *sqlc.Queries }`
- `func New(db *sql.DB) *Store`

Implement `internal/entry.Store` by delegating to sqlc:
- `UserGetByID`, `UserGetByEmail`, `UserCreate`, `UserCountByRole`
- plus condos/visits methods that currently exist in memstore.

Implementation details:
- Use context-aware sqlc methods.
- Normalize errors: `sql.ErrNoRows` -> `entry.ErrNotFound`.
- If the app expects IDs as `int64`, ensure sqlc emits compatible types.

### Step 5 — Production DB wiring in main
Update `cmd/entry-watch/main.go`:

1) Ensure `./data` exists (create on startup if missing).
2) Default DSN:
   - `./data/db.sqlite3` (env override later; for now support `DATABASE_URL` or `ENTRYWATCH_DB_DSN`).
3) Open DB with modernc driver (likely `sql.Open("sqlite", dsn)`), and set pragmas if needed:
   - foreign keys ON (either via DSN pragmas or `PRAGMA foreign_keys=ON;` after open).
4) Run migrations:
   - `db.AutoMigrate(dbConn, logger)` (from `db/migrate.go`).
5) Construct sqlstore and app:
   - `store := sqlstore.New(dbConn)`
   - `app := entry.NewApp(logger, store)`
6) Keep existing bootstrap logic (superadmin) intact.

### Step 6 — Tests: migrate to in-memory sqlite per test
Replace `NewMemStore()` usage in tests with:

- Helper `openTestDB(t)`:
  - opens sqlite with `file::memory:?cache=shared` (or `:memory:` with single connection)
  - `db.SetMaxOpenConns(1)` for determinism
  - runs `db.AutoMigrate(dbConn, logger)`
  - closes on cleanup

Then:
- `store := sqlstore.New(dbConn)`
- `app := entry.NewApp(logger, store)`

Update the existing test file:
- `internal/entry/app_test.go` -> SQL-backed.

Optional additions (if needed by compilation):
- new test helper package `internal/testutil` (or local helper in the test file).

---

## Verification

### Local build tooling
- `make templates` (templ generation)
- `make sqlc` (sqlc generation)
- `make build` (ensures generation prerequisites and builds)

### Tests
- `go test ./...` (uses in-memory sqlite per test)

### Manual smoke
- Run server and verify DB file created:
  - `go run ./cmd/entry-watch`
  - confirm `./data/db.sqlite3` exists
- Verify bootstrap superadmin still works (login with default credentials).

---

## Execution order (recommended)
1) Implement sqlc queries + generated code.
2) Implement `internal/entry/sqlstore` and satisfy `entry.Store`.
3) Wire sqlite store into `cmd/entry-watch/main.go` (replace memstore).
4) Migrate tests to sqlite in-memory.
5) Template adjustments (login + any missing pages), regenerating templ outputs.

---

## Commit cadence (recommended)
Make regular, focused commits at these checkpoints:

- `feat(sqlc): add db/sqlc/*.sql queries` — after adding all sqlc query files.
- `chore(sqlc): run sqlc generated code (generated)` — after running sqlc and committing generated code.
- `feat(store): add sqlite-backed sqlstore implementation` — after implementing `internal/entry/sqlstore` and its methods.
- `chore(main): wire sqlite store and migrations` — after updating `cmd/entry-watch/main.go` to open DB and run migrations.
- `test(db): migrate tests to in-memory sqlite` — after updating tests and adding test helpers.
- `feat(templ): add/adjust templ templates and regenerate (generated)` — after templ edits and generated `*_templ.go` changes.

Guidelines:
- Keep commits small and focused (single logical change).
- Include a short description and the “why” in the commit message body if non-obvious.
- Commit generated files (sqlc generated code and `*_templ.go`) only when they are validated to build; tag messages with `(generated)`.
- Avoid committing secrets or private keys; regenerate keys in production config instead.

This will help reviewability and make it easier to bisect or revert specific steps.

---

## Session progress tracking (for multi-session work)

Use this section as a running checklist for the *current* execution session. Update it as work progresses so a later session can pick up quickly.

When everything is finished, create a file `plan-finished` at the root of the project.


- Session date/time: 
- Branch/commit at start: auth (working branch)
- Completed:
  - []
- In progress:
- Completed in this session:
  - [x] Added `/auth/login` templ and generated output
  - [x] Render `/auth/login` using templ in auth handler
- Blockers / open questions:
  - (fill)

## Lessons learned

Use this section to jot down any lessons learned during implementation for
future reference.

* Dont edit generated files directly, regerate them with `make templates` or
  `make sqlc`.
