# Plan: Password auth + role context in canonical logger

## Goal
Implement password-based authentication for `entry-watch`, using `reference-proyect` as reference, with these project-specific requirements:

1) Authentication + user role lookup happens in `CanonicalLoggerMiddleware`, and the authenticated user is put into request context.
2) From that point onward, authorization checks use the context (`entry.UserFromCtx` / `entry.RequireRole*`).
3) On server start, if there is no `superadmin` user, create one with default password `password`.

Project roles (already defined): `superadmin`, `admin`, `guard`, `user`.

---

## Reference-proyect patterns to reuse
Reference uses `gorilla/sessions` + `bcrypt`:

- `reference-proyect/internal/http/operators/auth.go`
  - `bcrypt.GenerateFromPassword` on user create
  - `bcrypt.CompareHashAndPassword` on login
  - `sessions.Store.Get(...)` and sets `session.Values[...]` and `s.Save(...)`

We’ll adapt to:
- email+password login (entry-watch has unique `users.email`)
- role derived from DB user record
- contextual auth in `CanonicalLoggerMiddleware`

---

## Phase 1 — Understand current state (read-only)
Key current files (already identified):

- `internal/http/middleware.go`
  - `CanonicalLoggerMiddleware` currently injects a mock `superadmin` user
- `internal/http/server.go`
  - wires global middlewares
- `internal/http/routes.go`
  - does **not** currently mount `/auth/` (commented TODO)
- `internal/http/auth/auth.go`
  - stub only
- `internal/entry/user.go`
  - contains roles + context helper + `RequireRole` / `RequireRoleAndCondo`
- `db/current-schema.sql` / `db/migrations/20251123181233_init.sql`
  - `users` table includes: `email`, `role`, `password`, `enabled`, `hidden`

---

## Phase 2 — Design decisions

### Auth mechanism
Use `gorilla/sessions` (cookie-backed) with signed (and optionally encrypted) cookies.

- Cookie name: `entrywatch_session`
- Session key for app: `auth`
- Stored values:
  - `uid` (int64): canonical user id

Keep the session minimal: treat DB as source of truth for role/condo/enabled.

### Password hashing
Use `golang.org/x/crypto/bcrypt`.

- On create: `bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)`
- On login: `bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))`

### Cookie options
Centralize setting options:
- `Path: "/"`
- `HttpOnly: true`
- `SameSite: http.SameSiteStrictMode` (preferred; relax to `Lax` only if needed for UX)
- `Secure: true` always (required by modern browsers; local dev should use HTTPS or a local reverse proxy providing TLS)
- `MaxAge`: e.g. 12h or 24h
- Logout: set `MaxAge = -1`

### Where role is checked
- Authentication (identify user) happens in `CanonicalLoggerMiddleware`.
- Authorization (role restrictions) stays as route middleware using `entry.RequireRole*`.

This matches the requirement “checked in canonical logger middleware, put into context, checked from context from there on out”.

---

## Phase 3 — Implementation steps (what to change)

### 1) Introduce a real user persistence API in the store
**Why**: `CanonicalLoggerMiddleware` must be able to load the user by session key.

Planned changes:
- Add user-focused methods to the app/store layer used by HTTP:
  - `UserGetByID(ctx, id)`
  - `UserGetByEmail(ctx, email)`
  - `UserCreate(ctx, params)` (used for bootstrap and optional future admin tools)
  - `SuperadminExists(ctx)` or `UserCountByRole(ctx, RoleSuperAdmin)`

**Likely file targets** (exact store location to confirm during implementation):
- `internal/entry/app.go` (extend App to expose user store)
- existing db/store package under `internal/...` (where other queries live)
- `sqlc.yaml` + generated code if project already uses sqlc (present in root)

Note: DB schema already has `users.password TEXT NOT NULL`.
- Do not rename columns in this change unless requested.
- Treat it as `password_hash` semantically.

### 2) Implement auth HTTP endpoints
Mount `/auth/` and implement minimal login/logout.

**Routes**:
- `GET /auth/login`
- `POST /auth/login`
- `POST /auth/logout` (or `GET /auth/logout` if you prefer consistency with existing patterns)

**Login handler behavior**:
- read `email` + `password`
- lookup user by email
- verify bcrypt
- set session `uid`
- redirect by role:
  - superadmin → `/super/`
  - admin → `/admin/`
  - guard → `/guard/`
  - user → `/neighbor/`

**Logout**:
- clear session (`MaxAge=-1`) and redirect to `/auth/login`

**Files**:
- `internal/http/auth/auth.go` (replace stub with real handlers + Handle function)
- `internal/http/routes.go` (uncomment/add `mux.Handle("/auth/", auth.Handle(...))`)
- templates: add a login template if not already present in this project

### 3) Add gorilla/sessions store initialization
We need a session store instance available to:
- `CanonicalLoggerMiddleware`
- `/auth/login` and `/auth/logout` handlers

**Approach**:
- Add to `entry.App` a sessions store instance (or add to `internal/http` server construction).
- Prefer: create in `internal/http/server.go` and pass into middleware/router constructors, to keep transport concerns in http package.

Configuration:
- session auth key (and optional encryption key) from env/config.
- In dev, allow a default key with a loud warning.

### 4) Update CanonicalLoggerMiddleware to perform authn + set context user
This is the central requirement.

Current state:
- `internal/http/middleware.go` injects a fake superadmin.

Planned:
- Update signature to accept `app *entry.App` and `session sessions.Store`.
- In the middleware:
  1) load session
  2) if there is a `uid`, fetch user record from store
  3) if found and not disabled (and optionally not hidden), call:
     - `entry.WithUser(ctx, &entry.User{ID: ..., CondominiumID: ..., Role: ..., Enabled: ...})`
  4) if invalid session, clear it (best-effort) and continue unauthenticated
  5) proceed with logging as today

Important: do not redirect from the canonical logger middleware (keep it side-effect-light); existing route auth middleware can redirect or return 401/403.

**Files**:
- `internal/http/middleware.go`
- `internal/http/server.go` (wiring signature changes)

### 5) Ensure route-level authorization relies on context
The `neighbor` routes already do this:
- `internal/http/user/routes.go` uses `entry.RequireRole(r.Context(), entry.RoleUser)`

Add consistent middleware to the other route groups if/when routes exist:
- `internal/http/admin/routes.go` → require `RoleAdmin`
- `internal/http/guard/routes.go` → require `RoleGuardian`
- `internal/http/superadmin/routes.go` → require `RoleSuperAdmin`

(No need to change handlers if they already rely on context role checks.)

### 6) Bootstrap superadmin on server start
Requirement: if no superadmin exists, create one with default password `password`.

Planned:
- Add `app.Bootstrap(ctx)` or `app.BootstrapSuperadmin(ctx)`:
  - checks existence
  - if none:
    - create a user with role `superadmin`, enabled true, hidden false
    - choose default email (needs decision; see questions)
    - bcrypt-hash `password`

Wire it at startup:
- `cmd/entry-watch/main.go`:
  - after initializing real store + app, call bootstrap
  - if bootstrap fails, fail fast

---

## Open questions to confirm before implementation
1) What should the bootstrap superadmin email be?
   - e.g. `superadmin@local` by default, or env-driven.
2) Should `hidden=true` users be treated as unauthenticated (same as disabled), or allowed to log in but restricted?
3) Should unauthenticated access redirect to `/auth/login` (browser UX) or return `401` JSON/plaintext? (Current `util.HandleError` maps 401/403; neighbor routes currently just error, not redirect.)

---

## Session progress tracking (for multi-session work)

Use this section as a running checklist for the *current* execution session. Update it as work progresses so a later session can pick up quickly.

- Session date/time: 2026-01-16
- Branch/commit at start: auth (working branch)
- Completed:
  - [x] Bootstrap superadmin implemented in `entry.App` and wired in `cmd/entry-watch/main.go`
- In progress:
- [x] Implement cookie/session-backed login/logout handlers
- Next up:
- [x] Add `gorilla/sessions` store and update `CanonicalLoggerMiddleware` to read session and populate context
- Blockers / open questions:
  - (fill)

## Lessons learned (append-only)

Record short, actionable notes that will help future sessions continue the work efficiently. Include commands, file locations, pitfalls, and repo-specific conventions.

* Dont implement in memory stores; sqlite is used in production, so in memory sqlite will be used for tests.
- Never edit generated code. Always regenerate via the appropriate `make` targets, e.g. `make sqlc`, `make templates`.

## Verification plan

### Unit/store
- Test `BootstrapSuperadmin`:
  - empty DB → creates one superadmin
  - second run → no duplicates

### HTTP behavior (manual)
1) Start with a fresh DB.
2) Confirm superadmin created.
3) `POST /auth/login` with the bootstrap credentials → sets cookie.
4) Request a protected route:
   - without cookie → should fail authorization (401/redirect, depending on final UX decision)
   - with cookie → should populate context user in `CanonicalLoggerMiddleware` and pass role checks.
5) `POST /auth/logout` → clears cookie, subsequent protected requests fail.

### Commands
- `go test ./...`
- Run server (`make run` or `go run ./cmd/entry-watch`) and verify flows above.
